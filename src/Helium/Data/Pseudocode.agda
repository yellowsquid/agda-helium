------------------------------------------------------------------------
-- Agda Helium
--
-- Definition of types and operations used by the Armv8-M pseudocode.
------------------------------------------------------------------------

{-# OPTIONS --safe --without-K #-}

module Helium.Data.Pseudocode where

open import Algebra.Core
import Algebra.Definitions.RawSemiring as RS
open import Data.Bool.Base using (Bool; if_then_else_)
open import Data.Empty using (‚ä•-elim)
open import Data.Fin.Base as Fin hiding (cast)
import Data.Fin.Properties as F‚Çö
import Data.Fin.Induction as Induction
open import Data.Nat.Base using (‚Ñï; zero; suc)
open import Data.Sum using (_‚äé_; inj‚ÇÅ; inj‚ÇÇ; [_,_]‚Ä≤)
open import Data.Vec.Functional
open import Data.Vec.Functional.Relation.Binary.Pointwise using (Pointwise)
import Data.Vec.Functional.Relation.Binary.Pointwise.Properties as Pw‚Çö
open import Function using (_$_; _‚àò‚Ä≤_; id)
open import Helium.Algebra.Ordered.StrictTotal.Bundles
open import Helium.Algebra.Decidable.Bundles
  using (BooleanAlgebra; RawBooleanAlgebra)
import Helium.Algebra.Decidable.Construct.Pointwise as Pw
open import Helium.Algebra.Morphism.Structures
open import Level using (_‚äî_) renaming (suc to ‚Ñìsuc)
open import Relation.Binary.Core using (Rel)
open import Relation.Binary.Definitions
open import Relation.Binary.PropositionalEquality as P using (_‚â°_)
import Relation.Binary.Reasoning.StrictPartialOrder as Reasoning
open import Relation.Binary.Structures using (IsStrictTotalOrder)
open import Relation.Nullary using (does; yes; no)
open import Relation.Nullary.Decidable.Core
  using (False; toWitnessFalse; fromWitnessFalse)

record RawPseudocode b‚ÇÅ b‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ r‚ÇÅ r‚ÇÇ r‚ÇÉ : Set (‚Ñìsuc (b‚ÇÅ ‚äî b‚ÇÇ ‚äî i‚ÇÅ ‚äî i‚ÇÇ ‚äî i‚ÇÉ ‚äî r‚ÇÅ ‚äî r‚ÇÇ ‚äî r‚ÇÉ)) where
  field
    bitRawBooleanAlgebra : RawBooleanAlgebra b‚ÇÅ b‚ÇÇ
    integerRawRing : RawRing i‚ÇÅ i‚ÇÇ i‚ÇÉ
    realRawField : RawField r‚ÇÅ r‚ÇÇ r‚ÇÉ

  bitsRawBooleanAlgebra : ‚Ñï ‚Üí RawBooleanAlgebra b‚ÇÅ b‚ÇÇ
  bitsRawBooleanAlgebra =  Pw.rawBooleanAlgebra  bitRawBooleanAlgebra

  module ùîπ = RawBooleanAlgebra bitRawBooleanAlgebra
    renaming (Carrier to Bit; ‚ä§ to 1ùîπ; ‚ä• to 0ùîπ)
  module Bits {n} = RawBooleanAlgebra (bitsRawBooleanAlgebra n)
    renaming (‚ä§ to ones; ‚ä• to zeros)
  module ‚Ñ§ = RawRing integerRawRing renaming (Carrier to ‚Ñ§; 1# to 1‚Ñ§; 0# to 0‚Ñ§)
  module ‚Ñù = RawField realRawField renaming (Carrier to ‚Ñù; 1# to 1‚Ñù; 0# to 0‚Ñù)
  module ‚Ñ§‚Ä≤ = RS ‚Ñ§.Unordered.rawSemiring
  module ‚Ñù‚Ä≤ = RS ‚Ñù.Unordered.rawSemiring

  Bits : ‚Ñï ‚Üí Set b‚ÇÅ
  Bits n = Bits.Carrier {n}

  open ùîπ public using (Bit; 1ùîπ; 0ùîπ)
  open Bits public using (ones; zeros)
  open ‚Ñ§ public using (‚Ñ§; 1‚Ñ§; 0‚Ñ§)
  open ‚Ñù public using (‚Ñù; 1‚Ñù; 0‚Ñù)

  infix 4 _‚âü·∂ª_ _<·∂ª?_ _‚âü ≥_ _< ≥?_ _‚âü·µá‚ÇÅ_ _‚âü·µá_
  field
    _‚âü·∂ª_  : Decidable ‚Ñ§._‚âà_
    _<·∂ª?_ : Decidable ‚Ñ§._<_
    _‚âü ≥_  : Decidable ‚Ñù._‚âà_
    _< ≥?_ : Decidable ‚Ñù._<_
    _‚âü·µá‚ÇÅ_ : Decidable ùîπ._‚âà_

  _‚âü·µá_ : ‚àÄ {n} ‚Üí Decidable (Bits._‚âà_ {n})
  _‚âü·µá_ = Pw‚Çö.decidable _‚âü·µá‚ÇÅ_

  field
    _/1 : ‚Ñ§ ‚Üí ‚Ñù
    ‚åä_‚åã : ‚Ñù ‚Üí ‚Ñ§

  cast : ‚àÄ {m n} ‚Üí .(eq : m ‚â° n) ‚Üí Bits m ‚Üí Bits n
  cast eq x i = x $ Fin.cast (P.sym eq) i

  2‚Ñ§ : ‚Ñ§
  2‚Ñ§ = 2 ‚Ñ§‚Ä≤.√ó‚Ä≤ 1‚Ñ§

  get·µá : ‚àÄ {n} ‚Üí Fin n ‚Üí Bits n ‚Üí Bit
  get·µá i x = x (opposite i)

  set·µá : ‚àÄ {n} ‚Üí Fin n ‚Üí Bit ‚Üí Op‚ÇÅ (Bits n)
  set·µá i b = updateAt (opposite i) Œª _ ‚Üí b

  slice·µá : ‚àÄ {n} (i : Fin (suc n)) j ‚Üí Bits n ‚Üí Bits (to‚Ñï (i - j))
  slice·µá         zero    zero    x = []
  slice·µá {suc n} (suc i) zero    x = get·µá i x ‚à∑ slice·µá i zero (tail x)
  slice·µá {suc n} (suc i) (suc j) x = slice·µá i j (tail x)

  update·µá : ‚àÄ {n} (i : Fin (suc n)) j ‚Üí Bits (to‚Ñï (i - j)) ‚Üí Op‚ÇÅ (Bits n)
  update·µá {n} = Induction.<-weakInduction P (Œª _ _ ‚Üí id) helper
    where
    P : Fin (suc n) ‚Üí Set b‚ÇÅ
    P i = ‚àÄ j ‚Üí Bits (to‚Ñï (i - j)) ‚Üí Op‚ÇÅ (Bits n)

    eq : ‚àÄ {n} {i : Fin n} ‚Üí to‚Ñï i ‚â° to‚Ñï (inject‚ÇÅ i)
    eq = P.sym $ F‚Çö.to‚Ñï-inject‚ÇÅ _

    eq‚Ä≤ : ‚àÄ {n} {i : Fin n} j ‚Üí to‚Ñï (i - j) ‚â° to‚Ñï (inject‚ÇÅ i - Fin.cast eq j)
    eq‚Ä≤             zero    = eq
    eq‚Ä≤ {i = suc _} (suc j) = eq‚Ä≤ j

    helper : ‚àÄ i ‚Üí P (inject‚ÇÅ i) ‚Üí P (suc i)
    helper i rec zero    y = rec zero (cast eq (tail y)) ‚àò‚Ä≤ set·µá i (y zero)
    helper i rec (suc j) y = rec (Fin.cast eq j) (cast (eq‚Ä≤ j) y)

  hasBit : ‚àÄ {n} ‚Üí Fin n ‚Üí Bits n ‚Üí Bool
  hasBit i x = does (get·µá i x ‚âü·µá‚ÇÅ 1ùîπ)

  infixl 7 _div_ _mod_

  _div_ : ‚àÄ (x y : ‚Ñ§) ‚Üí {y‚ââ0 : False (y /1 ‚âü ≥ 0‚Ñù)} ‚Üí ‚Ñ§
  (x div y) {y‚ââ0} = ‚åä x /1 ‚Ñù.* toWitnessFalse y‚ââ0 ‚Ñù.‚Åª¬π ‚åã

  _mod_ : ‚àÄ (x y : ‚Ñ§) ‚Üí {y‚ââ0 : False (y /1 ‚âü ≥ 0‚Ñù)} ‚Üí ‚Ñ§
  (x mod y) {y‚ââ0} = x ‚Ñ§.+ ‚Ñ§.- y ‚Ñ§.* (x div y) {y‚ââ0}

  infixl 5 _<<_
  _<<_ : ‚Ñ§ ‚Üí ‚Ñï ‚Üí ‚Ñ§
  x << n = 2‚Ñ§ ‚Ñ§‚Ä≤.^‚Ä≤ n ‚Ñ§.* x

  module ShiftNotZero
    (1<<n‚ââ0 : ‚àÄ n ‚Üí False ((1‚Ñ§ << n) /1 ‚âü ≥ 0‚Ñù))
    where

    infixl 5 _>>_
    _>>_ : ‚Ñ§ ‚Üí ‚Ñï ‚Üí ‚Ñ§
    x >> zero  = x
    x >> suc n = (x div (1‚Ñ§ << suc n)) {1<<n‚ââ0 (suc n)}

    get·∂ª : ‚Ñï ‚Üí ‚Ñ§ ‚Üí Bit
    get·∂ª n x =
      if does ((x mod (1‚Ñ§ << suc n)) {1<<n‚ââ0 (suc n)} <·∂ª? 1‚Ñ§ << n)
      then 1ùîπ
      else 0ùîπ

    slice·∂ª : ‚àÄ n i ‚Üí ‚Ñ§ ‚Üí Bits (n ‚Ñï-‚Ñï i)
    slice·∂ª zero    zero    x = []
    slice·∂ª (suc n) zero    x = get·∂ª n x ‚à∑ slice·∂ª n zero x
    slice·∂ª (suc n) (suc i) x = slice·∂ª n i (x >> 1)

  uint : ‚àÄ {n} ‚Üí Bits n ‚Üí ‚Ñ§
  uint x = ‚Ñ§‚Ä≤.sum Œª i ‚Üí if hasBit i x then 1‚Ñ§ << to‚Ñï i else 0‚Ñ§

  sint : ‚àÄ {n} ‚Üí Bits n ‚Üí ‚Ñ§
  sint {zero}  x = 0‚Ñ§
  sint {suc n} x = uint x ‚Ñ§.+ ‚Ñ§.- (if hasBit (from‚Ñï n) x then 1‚Ñ§ << suc n else 0‚Ñ§)

record Pseudocode b‚ÇÅ b‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ r‚ÇÅ r‚ÇÇ r‚ÇÉ :
                  Set (‚Ñìsuc (b‚ÇÅ ‚äî b‚ÇÇ ‚äî i‚ÇÅ ‚äî i‚ÇÇ ‚äî i‚ÇÉ ‚äî r‚ÇÅ ‚äî r‚ÇÇ ‚äî r‚ÇÉ)) where
  field
    bitBooleanAlgebra : BooleanAlgebra b‚ÇÅ b‚ÇÇ
    integerRing       : CommutativeRing i‚ÇÅ i‚ÇÇ i‚ÇÉ
    realField         : Field r‚ÇÅ r‚ÇÇ r‚ÇÉ

  bitsBooleanAlgebra : ‚Ñï ‚Üí BooleanAlgebra b‚ÇÅ b‚ÇÇ
  bitsBooleanAlgebra = Pw.booleanAlgebra bitBooleanAlgebra

  module ùîπ = BooleanAlgebra bitBooleanAlgebra
    renaming (Carrier to Bit; ‚ä§ to 1ùîπ; ‚ä• to 0ùîπ)
  module Bits {n} = BooleanAlgebra (bitsBooleanAlgebra n)
    renaming (‚ä§ to ones; ‚ä• to zeros)
  module ‚Ñ§ = CommutativeRing integerRing
    renaming (Carrier to ‚Ñ§; 1# to 1‚Ñ§; 0# to 0‚Ñ§)
  module ‚Ñù = Field realField
    renaming (Carrier to ‚Ñù; 1# to 1‚Ñù; 0# to 0‚Ñù)

  Bits : ‚Ñï ‚Üí Set b‚ÇÅ
  Bits n = Bits.Carrier {n}

  open ùîπ public using (Bit; 1ùîπ; 0ùîπ)
  open Bits public using (ones; zeros)
  open ‚Ñ§ public using (‚Ñ§; 1‚Ñ§; 0‚Ñ§)
  open ‚Ñù public using (‚Ñù; 1‚Ñù; 0‚Ñù)

  module ‚Ñ§-Reasoning = Reasoning ‚Ñ§.strictPartialOrder
  module ‚Ñù-Reasoning = Reasoning ‚Ñù.strictPartialOrder

  field
    integerDiscrete : ‚àÄ x y ‚Üí y ‚Ñ§.‚â§ x ‚äé x ‚Ñ§.+ 1‚Ñ§ ‚Ñ§.‚â§ y
    1‚ââ0 : 1‚Ñ§ ‚Ñ§.‚ââ 0‚Ñ§

    _/1 : ‚Ñ§ ‚Üí ‚Ñù
    ‚åä_‚åã : ‚Ñù ‚Üí ‚Ñ§
    /1-isHomo : IsRingHomomorphism ‚Ñ§.Unordered.rawRing ‚Ñù.Unordered.rawRing _/1
    ‚åä‚åã-isHomo : IsRingHomomorphism ‚Ñù.Unordered.rawRing ‚Ñ§.Unordered.rawRing ‚åä_‚åã
    /1-mono : ‚àÄ x y ‚Üí x ‚Ñ§.< y ‚Üí x /1 ‚Ñù.< y /1
    ‚åä‚åã-floor : ‚àÄ x y ‚Üí x ‚Ñ§.‚â§ ‚åä y ‚åã ‚Üí ‚åä y ‚åã ‚Ñ§.< x ‚Ñ§.+ 1‚Ñ§
    ‚åä‚åã‚àò/1‚âóid : ‚àÄ x ‚Üí ‚åä x /1 ‚åã ‚Ñ§.‚âà x

  module /1 = IsRingHomomorphism /1-isHomo renaming (‚ü¶‚üß-cong to cong)
  module ‚åä‚åã = IsRingHomomorphism ‚åä‚åã-isHomo renaming (‚ü¶‚üß-cong to cong)

  bitRawBooleanAlgebra : RawBooleanAlgebra b‚ÇÅ b‚ÇÇ
  bitRawBooleanAlgebra = record
    { _‚âà_ = _‚âà_
    ; _‚à®_ = _‚à®_
    ; _‚àß_ = _‚àß_
    ; ¬¨_  = ¬¨_
    ; ‚ä§   = ‚ä§
    ; ‚ä•   = ‚ä•
    }
    where open BooleanAlgebra bitBooleanAlgebra

  rawPseudocode : RawPseudocode b‚ÇÅ b‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ r‚ÇÅ r‚ÇÇ r‚ÇÉ
  rawPseudocode = record
    { bitRawBooleanAlgebra = bitRawBooleanAlgebra
    ; integerRawRing = ‚Ñ§.rawRing
    ; realRawField = ‚Ñù.rawField
    ; _‚âü·∂ª_ = ‚Ñ§._‚âü_
    ; _<·∂ª?_ = ‚Ñ§._<?_
    ; _‚âü ≥_ = ‚Ñù._‚âü_
    ; _< ≥?_ = ‚Ñù._<?_
    ; _‚âü·µá‚ÇÅ_ = ùîπ._‚âü_
    ; _/1 = _/1
    ; ‚åä_‚åã = ‚åä_‚åã
    }

  open RawPseudocode rawPseudocode public
    using
    ( 2‚Ñ§; cast; get·µá; set·µá; slice·µá; update·µá; hasBit
    ; _div_; _mod_; _<<_; uint; sint
    )

  private
    -- FIXME: move almost all of these proofs into a separate module
    a<b‚áíca<cb : ‚àÄ {a b c} ‚Üí 0‚Ñ§ ‚Ñ§.< c ‚Üí a ‚Ñ§.< b ‚Üí c ‚Ñ§.* a ‚Ñ§.< c ‚Ñ§.* b
    a<b‚áíca<cb {a} {b} {c} 0<c a<b = begin-strict
      c ‚Ñ§.* a                     ‚âàÀò‚ü® ‚Ñ§.+-identity ≥ _ ‚ü©
      c ‚Ñ§.* a ‚Ñ§.+ 0‚Ñ§              <‚ü®  ‚Ñ§.+-invariantÀ° _ $ ‚Ñ§.0<a+0<b‚áí0<ab 0<c 0<b-a ‚ü©
      c ‚Ñ§.* a ‚Ñ§.+ c ‚Ñ§.* (b ‚Ñ§.- a) ‚âàÀò‚ü® ‚Ñ§.distribÀ° c a (b ‚Ñ§.- a) ‚ü©
      c ‚Ñ§.* (a ‚Ñ§.+ (b ‚Ñ§.- a))     ‚âà‚ü®  ‚Ñ§.*-congÀ° $ ‚Ñ§.+-congÀ° $ ‚Ñ§.+-comm b (‚Ñ§.- a) ‚ü©
      c ‚Ñ§.* (a ‚Ñ§.+ (‚Ñ§.- a ‚Ñ§.+ b)) ‚âàÀò‚ü® ‚Ñ§.*-congÀ° $ ‚Ñ§.+-assoc a (‚Ñ§.- a) b ‚ü©
      c ‚Ñ§.* ((a ‚Ñ§.+ ‚Ñ§.- a) ‚Ñ§.+ b) ‚âà‚ü®  ‚Ñ§.*-congÀ° $ ‚Ñ§.+-cong ≥ $ ‚Ñ§.-‚Äøinverse ≥ a ‚ü©
      c ‚Ñ§.* (0‚Ñ§ ‚Ñ§.+ b)            ‚âà‚ü®  (‚Ñ§.*-congÀ° $ ‚Ñ§.+-identityÀ° b) ‚ü©
      c ‚Ñ§.* b                     ‚àé
      where
      open ‚Ñ§-Reasoning

      0<b-a : 0‚Ñ§ ‚Ñ§.< b ‚Ñ§.- a
      0<b-a = begin-strict
        0‚Ñ§      ‚âàÀò‚ü® ‚Ñ§.-‚Äøinverse ≥ a ‚ü©
        a ‚Ñ§.- a <‚ü®  ‚Ñ§.+-invariant ≥ (‚Ñ§.- a) a<b ‚ü©
        b ‚Ñ§.- a ‚àé

    -‚Äøidem : ‚àÄ x ‚Üí ‚Ñ§.- (‚Ñ§.- x) ‚Ñ§.‚âà x
    -‚Äøidem x = begin-equality
      ‚Ñ§.- (‚Ñ§.- x)             ‚âàÀò‚ü® ‚Ñ§.+-identityÀ° _ ‚ü©
      0‚Ñ§ ‚Ñ§.- ‚Ñ§.- x            ‚âàÀò‚ü® ‚Ñ§.+-cong ≥ $ ‚Ñ§.-‚Äøinverse ≥ x ‚ü©
      x ‚Ñ§.- x ‚Ñ§.- ‚Ñ§.- x       ‚âà‚ü®  ‚Ñ§.+-assoc x (‚Ñ§.- x) _ ‚ü©
      x ‚Ñ§.+ (‚Ñ§.- x ‚Ñ§.- ‚Ñ§.- x) ‚âà‚ü®  ‚Ñ§.+-congÀ° $ ‚Ñ§.-‚Äøinverse ≥ (‚Ñ§.- x) ‚ü©
      x ‚Ñ§.+ 0‚Ñ§                ‚âà‚ü®  ‚Ñ§.+-identity ≥ x ‚ü©
      x                       ‚àé
      where open ‚Ñ§-Reasoning

    -a*b‚âà-ab : ‚àÄ a b ‚Üí ‚Ñ§.- a ‚Ñ§.* b ‚Ñ§.‚âà ‚Ñ§.- (a ‚Ñ§.* b)
    -a*b‚âà-ab a b = begin-equality
      ‚Ñ§.- a ‚Ñ§.* b                           ‚âàÀò‚ü® ‚Ñ§.+-identity ≥ _ ‚ü©
      ‚Ñ§.- a ‚Ñ§.* b ‚Ñ§.+ 0‚Ñ§                    ‚âàÀò‚ü® ‚Ñ§.+-congÀ° $ ‚Ñ§.-‚Äøinverse ≥ _ ‚ü©
      ‚Ñ§.- a ‚Ñ§.* b ‚Ñ§.+ (a ‚Ñ§.* b ‚Ñ§.- a ‚Ñ§.* b) ‚âàÀò‚ü® ‚Ñ§.+-assoc _ _ _ ‚ü©
      ‚Ñ§.- a ‚Ñ§.* b ‚Ñ§.+ a ‚Ñ§.* b ‚Ñ§.- a ‚Ñ§.* b   ‚âàÀò‚ü® ‚Ñ§.+-cong ≥ $ ‚Ñ§.distrib ≥ b _ a ‚ü©
      (‚Ñ§.- a ‚Ñ§.+ a) ‚Ñ§.* b ‚Ñ§.- a ‚Ñ§.* b       ‚âà‚ü®  ‚Ñ§.+-cong ≥ $ ‚Ñ§.*-cong ≥ $ ‚Ñ§.-‚ÄøinverseÀ° a ‚ü©
      0‚Ñ§ ‚Ñ§.* b ‚Ñ§.- a ‚Ñ§.* b                  ‚âà‚ü®  ‚Ñ§.+-cong ≥ $ ‚Ñ§.zeroÀ° b ‚ü©
      0‚Ñ§ ‚Ñ§.- a ‚Ñ§.* b                        ‚âà‚ü®  ‚Ñ§.+-identityÀ° _ ‚ü©
      ‚Ñ§.- (a ‚Ñ§.* b)                         ‚àé
      where open ‚Ñ§-Reasoning

    a*-b‚âà-ab : ‚àÄ a b ‚Üí a ‚Ñ§.* ‚Ñ§.- b ‚Ñ§.‚âà ‚Ñ§.- (a ‚Ñ§.* b)
    a*-b‚âà-ab a b = begin-equality
      a ‚Ñ§.* ‚Ñ§.- b   ‚âà‚ü® ‚Ñ§.*-comm a (‚Ñ§.- b) ‚ü©
      ‚Ñ§.- b ‚Ñ§.* a   ‚âà‚ü® -a*b‚âà-ab b a ‚ü©
      ‚Ñ§.- (b ‚Ñ§.* a) ‚âà‚ü® ‚Ñ§.-‚Äøcong $ ‚Ñ§.*-comm b a ‚ü©
      ‚Ñ§.- (a ‚Ñ§.* b) ‚àé
      where open ‚Ñ§-Reasoning

    0<a‚áí0>-a : ‚àÄ {a} ‚Üí 0‚Ñ§ ‚Ñ§.< a ‚Üí 0‚Ñ§ ‚Ñ§.> ‚Ñ§.- a
    0<a‚áí0>-a {a} 0<a = begin-strict
      ‚Ñ§.- a    ‚âàÀò‚ü® ‚Ñ§.+-identityÀ° _ ‚ü©
      0‚Ñ§ ‚Ñ§.- a <‚ü®  ‚Ñ§.+-invariant ≥ _ 0<a ‚ü©
      a ‚Ñ§.- a  ‚âà‚ü®  ‚Ñ§.-‚Äøinverse ≥ a ‚ü©
      0‚Ñ§       ‚àé
      where open ‚Ñ§-Reasoning

    0>a‚áí0<-a : ‚àÄ {a} ‚Üí 0‚Ñ§ ‚Ñ§.> a ‚Üí 0‚Ñ§ ‚Ñ§.< ‚Ñ§.- a
    0>a‚áí0<-a {a} 0>a = begin-strict
      0‚Ñ§       ‚âàÀò‚ü® ‚Ñ§.-‚Äøinverse ≥ a ‚ü©
      a ‚Ñ§.- a  <‚ü®  ‚Ñ§.+-invariant ≥ _ 0>a ‚ü©
      0‚Ñ§ ‚Ñ§.- a ‚âà‚ü®  ‚Ñ§.+-identityÀ° _ ‚ü©
      ‚Ñ§.- a    ‚àé
      where open ‚Ñ§-Reasoning

    0<-a‚áí0>a : ‚àÄ {a} ‚Üí 0‚Ñ§ ‚Ñ§.< ‚Ñ§.- a ‚Üí 0‚Ñ§ ‚Ñ§.> a
    0<-a‚áí0>a {a} 0<-a = begin-strict
      a        ‚âàÀò‚ü® ‚Ñ§.+-identity ≥ a ‚ü©
      a ‚Ñ§.+ 0‚Ñ§ <‚ü®  ‚Ñ§.+-invariantÀ° a 0<-a ‚ü©
      a ‚Ñ§.- a  ‚âà‚ü®  ‚Ñ§.-‚Äøinverse ≥ a ‚ü©
      0‚Ñ§       ‚àé
      where open ‚Ñ§-Reasoning

    0>-a‚áí0<a : ‚àÄ {a} ‚Üí 0‚Ñ§ ‚Ñ§.> ‚Ñ§.- a ‚Üí 0‚Ñ§ ‚Ñ§.< a
    0>-a‚áí0<a {a} 0>-a = begin-strict
      0‚Ñ§       ‚âàÀò‚ü® ‚Ñ§.-‚Äøinverse ≥ a ‚ü©
      a ‚Ñ§.- a  <‚ü®  ‚Ñ§.+-invariantÀ° a 0>-a ‚ü©
      a ‚Ñ§.+ 0‚Ñ§ ‚âà‚ü®  ‚Ñ§.+-identity ≥ a ‚ü©
      a        ‚àé
      where open ‚Ñ§-Reasoning

    0>a+0<b‚áí0>ab : ‚àÄ {a b} ‚Üí 0‚Ñ§ ‚Ñ§.> a ‚Üí 0‚Ñ§ ‚Ñ§.< b ‚Üí 0‚Ñ§ ‚Ñ§.> a ‚Ñ§.* b
    0>a+0<b‚áí0>ab {a} {b} 0>a 0<b = 0<-a‚áí0>a $ begin-strict
      0‚Ñ§              <‚ü® ‚Ñ§.0<a+0<b‚áí0<ab (0>a‚áí0<-a 0>a) 0<b ‚ü©
      ‚Ñ§.- a ‚Ñ§.* b     ‚âà‚ü® -a*b‚âà-ab a b ‚ü©
      ‚Ñ§.- (a ‚Ñ§.* b)   ‚àé
      where open ‚Ñ§-Reasoning

    0<a+0>b‚áí0>ab : ‚àÄ {a b} ‚Üí 0‚Ñ§ ‚Ñ§.< a ‚Üí 0‚Ñ§ ‚Ñ§.> b ‚Üí 0‚Ñ§ ‚Ñ§.> a ‚Ñ§.* b
    0<a+0>b‚áí0>ab {a} {b} 0<a 0>b = 0<-a‚áí0>a $ begin-strict
      0‚Ñ§              <‚ü® ‚Ñ§.0<a+0<b‚áí0<ab 0<a (0>a‚áí0<-a 0>b) ‚ü©
      a ‚Ñ§.* ‚Ñ§.- b     ‚âà‚ü® a*-b‚âà-ab a b ‚ü©
      ‚Ñ§.- (a ‚Ñ§.* b)   ‚àé
      where open ‚Ñ§-Reasoning

    0>a+0>b‚áí0<ab : ‚àÄ {a b} ‚Üí 0‚Ñ§ ‚Ñ§.> a ‚Üí 0‚Ñ§ ‚Ñ§.> b ‚Üí 0‚Ñ§ ‚Ñ§.< a ‚Ñ§.* b
    0>a+0>b‚áí0<ab {a} {b} 0>a 0>b = begin-strict
      0‚Ñ§                  <‚ü® ‚Ñ§.0<a+0<b‚áí0<ab (0>a‚áí0<-a 0>a) (0>a‚áí0<-a 0>b) ‚ü©
      ‚Ñ§.- a ‚Ñ§.* ‚Ñ§.- b     ‚âà‚ü® -a*b‚âà-ab a (‚Ñ§.- b) ‚ü©
      ‚Ñ§.- (a ‚Ñ§.* ‚Ñ§.- b)   ‚âà‚ü® ‚Ñ§.-‚Äøcong $ a*-b‚âà-ab a b ‚ü©
      ‚Ñ§.- (‚Ñ§.- (a ‚Ñ§.* b)) ‚âà‚ü® -‚Äøidem (a ‚Ñ§.* b) ‚ü©
      a ‚Ñ§.* b             ‚àé
      where open ‚Ñ§-Reasoning

    a‚ââ0+b‚ââ0‚áíab‚ââ0 : ‚àÄ {a b} ‚Üí a ‚Ñ§.‚ââ 0‚Ñ§ ‚Üí b ‚Ñ§.‚ââ 0‚Ñ§ ‚Üí a ‚Ñ§.* b ‚Ñ§.‚ââ 0‚Ñ§
    a‚ââ0+b‚ââ0‚áíab‚ââ0 {a} {b} a‚ââ0 b‚ââ0 ab‚âà0 with ‚Ñ§.compare a 0‚Ñ§ | ‚Ñ§.compare b 0‚Ñ§
    ... | tri< a<0 _ _ | tri< b<0 _ _ = ‚Ñ§.irrefl (‚Ñ§.Eq.sym ab‚âà0) $ 0>a+0>b‚áí0<ab a<0 b<0
    ... | tri< a<0 _ _ | tri‚âà _ b‚âà0 _ = b‚ââ0 b‚âà0
    ... | tri< a<0 _ _ | tri> _ _ b>0 = ‚Ñ§.irrefl ab‚âà0 $ 0>a+0<b‚áí0>ab a<0 b>0
    ... | tri‚âà _ a‚âà0 _ | _            = a‚ââ0 a‚âà0
    ... | tri> _ _ a>0 | tri< b<0 _ _ = ‚Ñ§.irrefl ab‚âà0 $ 0<a+0>b‚áí0>ab a>0 b<0
    ... | tri> _ _ a>0 | tri‚âà _ b‚âà0 _ = b‚ââ0 b‚âà0
    ... | tri> _ _ a>0 | tri> _ _ b>0 = ‚Ñ§.irrefl (‚Ñ§.Eq.sym ab‚âà0) $ ‚Ñ§.0<a+0<b‚áí0<ab a>0 b>0

    ab‚âà0‚áía‚âà0‚äéb‚âà0 : ‚àÄ {a b} ‚Üí a ‚Ñ§.* b ‚Ñ§.‚âà 0‚Ñ§ ‚Üí a ‚Ñ§.‚âà 0‚Ñ§ ‚äé b ‚Ñ§.‚âà 0‚Ñ§
    ab‚âà0‚áía‚âà0‚äéb‚âà0 {a} {b} ab‚âà0 with a ‚Ñ§.‚âü 0‚Ñ§ | b ‚Ñ§.‚âü 0‚Ñ§
    ... | yes a‚âà0 | _       = inj‚ÇÅ a‚âà0
    ... | no a‚ââ0  | yes b‚âà0 = inj‚ÇÇ b‚âà0
    ... | no a‚ââ0  | no b‚ââ0  = ‚ä•-elim (a‚ââ0+b‚ââ0‚áíab‚ââ0 a‚ââ0 b‚ââ0 ab‚âà0)

    2a<<n‚âàa<<1+n : ‚àÄ a n ‚Üí 2‚Ñ§ ‚Ñ§.* (a << n) ‚Ñ§.‚âà a << suc n
    2a<<n‚âàa<<1+n a zero    = ‚Ñ§.*-congÀ° $ ‚Ñ§.*-identityÀ° a
    2a<<n‚âàa<<1+n a (suc n) = begin-equality
      2‚Ñ§ ‚Ñ§.* (a << suc n) ‚âàÀò‚ü® ‚Ñ§.*-assoc 2‚Ñ§ _ a ‚ü©
      (2‚Ñ§ ‚Ñ§.* _) ‚Ñ§.* a    ‚âà‚ü®  ‚Ñ§.*-cong ≥ $ ‚Ñ§.*-comm 2‚Ñ§ _ ‚ü©
      a << suc (suc n)    ‚àé
      where open ‚Ñ§-Reasoning

    0<1 : 0‚Ñ§ ‚Ñ§.< 1‚Ñ§
    0<1 with ‚Ñ§.compare 0‚Ñ§ 1‚Ñ§
    ... | tri< 0<1 _ _ = 0<1
    ... | tri‚âà _ 0‚âà1 _ = ‚ä•-elim (1‚ââ0 (‚Ñ§.Eq.sym 0‚âà1))
    ... | tri> _ _ 0>1 = begin-strict
        0‚Ñ§                  ‚âàÀò‚ü® ‚Ñ§.zero ≥ (‚Ñ§.- 1‚Ñ§) ‚ü©
        ‚Ñ§.- 1‚Ñ§ ‚Ñ§.* 0‚Ñ§       <‚ü®  a<b‚áíca<cb (0>a‚áí0<-a 0>1) (0>a‚áí0<-a 0>1) ‚ü©
        ‚Ñ§.- 1‚Ñ§ ‚Ñ§.* ‚Ñ§.- 1‚Ñ§   ‚âà‚ü®  -a*b‚âà-ab 1‚Ñ§ (‚Ñ§.- 1‚Ñ§) ‚ü©
        ‚Ñ§.- (1‚Ñ§ ‚Ñ§.* ‚Ñ§.- 1‚Ñ§) ‚âà‚ü®  ‚Ñ§.-‚Äøcong $ ‚Ñ§.*-identityÀ° (‚Ñ§.- 1‚Ñ§) ‚ü©
        ‚Ñ§.- (‚Ñ§.- 1‚Ñ§)        ‚âà‚ü®  -‚Äøidem 1‚Ñ§ ‚ü©
        1‚Ñ§                  ‚àé
      where open ‚Ñ§-Reasoning

    0<2 : 0‚Ñ§ ‚Ñ§.< 2‚Ñ§
    0<2 = begin-strict
      0‚Ñ§        ‚âàÀò‚ü® ‚Ñ§.+-identity¬≤ ‚ü©
      0‚Ñ§ ‚Ñ§.+ 0‚Ñ§ <‚ü®  ‚Ñ§.+-invariantÀ° 0‚Ñ§ 0<1 ‚ü©
      0‚Ñ§ ‚Ñ§.+ 1‚Ñ§ <‚ü®  ‚Ñ§.+-invariant ≥ 1‚Ñ§ 0<1 ‚ü©
      2‚Ñ§        ‚àé
      where open ‚Ñ§-Reasoning

    1<<n‚ââ0 : ‚àÄ n ‚Üí 1‚Ñ§ << n ‚Ñ§.‚ââ 0‚Ñ§
    1<<n‚ââ0 zero          eq = 1‚ââ0 1‚âà0
      where
      open ‚Ñ§-Reasoning
      1‚âà0 = begin-equality
        1‚Ñ§        ‚âàÀò‚ü® ‚Ñ§.*-identity¬≤ ‚ü©
        1‚Ñ§ ‚Ñ§.* 1‚Ñ§ ‚âà‚ü®  eq ‚ü©
        0‚Ñ§        ‚àé
    1<<n‚ââ0 (suc zero)    eq = ‚Ñ§.irrefl 0‚âà2 0<2
      where
      open ‚Ñ§-Reasoning
      0‚âà2 = begin-equality
        0‚Ñ§        ‚âàÀò‚ü® eq ‚ü©
        2‚Ñ§ ‚Ñ§.* 1‚Ñ§ ‚âà‚ü®  ‚Ñ§.*-identity ≥ 2‚Ñ§ ‚ü©
        2‚Ñ§        ‚àé
    1<<n‚ââ0 (suc (suc n)) eq =
      [ (Œª 2‚âà0 ‚Üí ‚Ñ§.irrefl (‚Ñ§.Eq.sym 2‚âà0) 0<2) , 1<<n‚ââ0 (suc n) ]‚Ä≤
      $ ab‚âà0‚áía‚âà0‚äéb‚âà0 $ ‚Ñ§.Eq.trans (2a<<n‚âàa<<1+n 1‚Ñ§ (suc n)) eq

    1<<n‚ââ0‚Ñù : ‚àÄ n ‚Üí (1‚Ñ§ << n) /1 ‚Ñù.‚ââ 0‚Ñù
    1<<n‚ââ0‚Ñù n eq = 1<<n‚ââ0 n $ (begin-equality
      1‚Ñ§ << n          ‚âàÀò‚ü® ‚åä‚åã‚àò/1‚âóid (1‚Ñ§ << n) ‚ü©
      ‚åä (1‚Ñ§ << n) /1 ‚åã ‚âà‚ü®  ‚åä‚åã.cong $ eq ‚ü©
      ‚åä 0‚Ñù ‚åã           ‚âà‚ü®  ‚åä‚åã.0#-homo ‚ü©
      0‚Ñ§               ‚àé)
      where open ‚Ñ§-Reasoning

    open RawPseudocode rawPseudocode using (module ShiftNotZero)

  open ShiftNotZero (Œª n ‚Üí fromWitnessFalse (1<<n‚ââ0‚Ñù n)) public
